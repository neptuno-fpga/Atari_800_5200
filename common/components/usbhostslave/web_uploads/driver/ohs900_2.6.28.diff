--- host.old/Kconfig	2008-11-28 11:22:54.000000000 +0100
+++ host/Kconfig	2008-11-28 11:38:40.000000000 +0100
@@ -17,6 +17,19 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called c67x00.
 
+config USB_OHS900_HCD
+    tristate "OHS900 HCD support"
+    depends on USB
+    default N
+    help
+      The OHS900 is a single-port USB controller that supports either
+      host side or peripheral side roles.  Enable this option if your
+      board has this core, and you want to use it as a host controller. 
+      If unsure, say N.
+
+      To compile this driver as a module, choose M here: the
+      module will be called ohs900-hcd. 
+
 config USB_EHCI_HCD
 	tristate "EHCI HCD (USB 2.0) support"
 	depends on USB && USB_ARCH_HAS_EHCI

--- host.old/Makefile	2008-11-28 11:22:54.000000000 +0100
+++ host/Makefile	2008-11-28 11:38:40.000000000 +0100
@@ -20,6 +20,7 @@
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
+obj-$(CONFIG_USB_OHS900_HCD)	+= ohs900-hcd.o
 obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
 obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
 obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o

--- host.old/ohs900.h	1970-01-01 01:00:00.000000000 +0100
+++ host/ohs900.h	2008-11-28 14:40:41.000000000 +0100
@@ -0,0 +1,288 @@
+/*
+ * OHS900 register declarations and HCD data structures
+ *
+ * Copyright (C) 2005 Steve Fielding
+ * Copyright (C) 2004 Psion Teklogix
+ * Copyright (C) 2004 David Brownell
+ */
+
+//#include <asm/arch/sam255.h>
+
+// base address of OHS900
+#define OHS900_BASE		na_usb //(DIMI_USB_HOST_PHYS)
+#define OHS900_IRQ		na_usb_irq //(SAM255_INTERRUPT_USB_HOST)
+#define OHS900SLAVE_BASE	na_usb //(DIMI_USB_HOST_PHYS)
+#define OHS900SLAVE_IRQ		na_usb_irq //(SAM255_INTERRUPT_USB_HOST)
+
+
+/*
+ * OHS900 has transfer registers, and control registers.  In host/master
+ * mode one set of registers is used; in peripheral/slave mode, another.
+ */
+
+
+/* TRANSFER REGISTERS
+ */
+#define OHS900_HOST_TX_CTLREG	0x00 
+#	define OHS900_HCTLMASK_TRANS_REQ		0x01 
+#	define OHS900_HCTLMASK_SOF_SYNC		0x02 
+#	define OHS900_HCTLMASK_PREAMBLE_EN	0x04 
+#	define OHS900_HCTLMASK_ISO_EN		0x08 
+
+
+#define OHS900_HRXSTATREG	0x0a	/* read */ 
+#	define OHS900_STATMASK_CRC_ERROR		0x01 
+#	define OHS900_STATMASK_BS_ERROR		0x02 
+#	define OHS900_STATMASK_RX_OVF		0x04 
+#	define OHS900_STATMASK_RX_TMOUT		0x08 
+#	define OHS900_STATMASK_NAK_RXED		0x10 
+#	define OHS900_STATMASK_STALL_RXED	0x20 
+#	define OHS900_STATMASK_ACK_RXED		0x40 
+#	define OHS900_STATMASK_DATA_SEQ		0x80 
+
+#define OHS900_TXTRANSTYPEREG		0x01	/* write */ 
+#	define	OHS900_SETUP	0x00 
+#	define	OHS900_IN	0x01 
+#	define	OHS900_OUT_DATA0	0x02 
+#	define	OHS900_OUT_DATA1	0x03 
+
+#define OHS900_TXADDRREG	0x04	
+#define OHS900_TXENDPREG	0x05	
+
+/* CONTROL REGISTERS:  
+ */
+#define OHS900_SOFENREG		0x03 
+#	define OHS900_MASK_SOF_ENA	0x01 
+
+#define OHS900_TXLINECTLREG 0x02 
+#	define OHS900_TXLCTL_MASK_FORCE	0x4 
+#	define OHS900_TXLCTL_MASK_LINE_CTRL_BITS 0x7
+#		define OHS900_TXLCTL_MASK_NORMAL	0x00 
+#		define OHS900_TXLCTL_MASK_SE0	0x04	
+#		define OHS900_TXLCTL_MASK_FS_J	0x06    
+#		define OHS900_TXLCTL_MASK_FS_K	0x05	
+#	define OHS900_TXLCTL_MASK_LSPD	0x00 
+#	define OHS900_TXLCTL_MASK_FSPD	0x18 
+#	define OHS900_TXLCTL_MASK_FS_POL	0x08 
+#	define OHS900_TXLCTL_MASK_FS_RATE 0x10 
+
+
+#define OHS900_IRQ_ENABLE	0x09             
+#	define OHS900_INTMASK_TRANS_DONE	0x01   
+#	define OHS900_INTMASK_SOFINTR	0x08   
+#	define OHS900_INTMASK_INSRMV	0x04   	
+#	define OHS900_INTMASK_RESUME_DET	0x02   
+		  
+#define OHS900_RXCONNSTATEREG 0x0e
+#define   OHS900_DISCONNECT_STATE 0x00
+#define   OHS900_LS_CONN_STATE 0x01
+#define   OHS900_FS_CONN_STATE 0x02
+
+#define OHS900_SLAVE_ADDRESS		0x54 
+
+
+
+#define OHS900_IRQ_STATUS	0x08	/* write to ack */ 
+#define OHS900_HWREVREG		0xe1	/* read */ 
+
+#define OHS900_SOFTMRREG		0x0F 
+
+
+
+#define OHS900_HOSTSLAVECTLREG 			0xe0 
+#	define OHS900_HSCTLREG_HOST_EN_MASK	0x01 
+#	define OHS900_HSCTLREG_RESET_CORE	0x02 
+
+
+
+#define OHS900_HS_CTL_INIT OHS900_HSCTLREG_HOST_EN_MASK 
+
+/* 64-byte FIFO control and status
+ */
+#define H_MAXPACKET	64		/* bytes in fifos */
+
+#define OHS900_HOST_TXFIFO_DATA	0x30 
+#define OHS900_TXFIFOCNTMSBREG	0x32 
+#define OHS900_TXFIFOCNTLSBREG	0x33
+#define OHS900_TXFIFOCONTROLREG	0x34
+#define OHS900_HOST_RXFIFO_DATA	0x20 
+#define OHS900_RXFIFOCNTMSBREG	0x22 
+#define OHS900_RXFIFOCNTLSBREG	0x23
+#define OHS900_RXFIFOCONTROLREG	0x24
+#define		OHS900_FIFO_FORCE_EMPTY 0x01
+
+
+#define OHS900_IO_EXTENT 0x100
+
+/*-------------------------------------------------------------------------*/
+
+#define	LOG2_PERIODIC_SIZE	5	/* arbitrary; this matches OHCI */
+#define	PERIODIC_SIZE		(1 << LOG2_PERIODIC_SIZE)
+
+struct ohs900 {
+	spinlock_t		lock;
+	void __iomem		*addr_reg;
+	struct ohs900_platform_data	*board;
+	struct proc_dir_entry	*pde;
+
+	unsigned long		stat_insrmv;
+	unsigned long		stat_wake;
+	unsigned long		stat_sof;
+	unsigned long		stat_a;
+	unsigned long		stat_b;
+	unsigned long		stat_lost;
+	unsigned long		stat_overrun;
+
+	/* sw model */
+	struct timer_list	timer;
+	struct ohs900h_ep	*next_periodic;
+	struct ohs900h_ep	*next_async;
+
+	struct ohs900h_ep	*active_a;
+	unsigned long		jiffies_a;
+	struct ohs900h_ep	*active_b;
+	unsigned long		jiffies_b;
+
+	u32			port1;
+	u8			ctrl1, ctrl2, irq_enable;
+	u16			frame;
+
+	/* async schedule: control, bulk */
+	struct list_head	async;
+
+	/* periodic schedule: interrupt, iso */
+	u16			load[PERIODIC_SIZE];
+	struct ohs900h_ep	*periodic[PERIODIC_SIZE];
+	unsigned		periodic_count;
+};
+
+static inline struct ohs900 *hcd_to_ohs900(struct usb_hcd *hcd)
+{
+	return (struct ohs900 *) (hcd->hcd_priv);
+}
+
+static inline struct usb_hcd *ohs900_to_hcd(struct ohs900 *ohs900)
+{
+	return container_of((void *) ohs900, struct usb_hcd, hcd_priv);
+}
+
+struct ohs900h_ep {
+	struct usb_host_endpoint *hep;
+	struct usb_device	*udev;
+
+	u8			defctrl;
+	u8			maxpacket;
+	u8			epnum;
+	u8			nextpid;
+
+	u16			error_count;
+	u16			nak_count;
+	u16			length;		/* of current packet */
+
+	/* periodic schedule */
+	u16			period;
+	u16			branch;
+	u16			load;
+	struct ohs900h_ep	*next;
+
+	/* async schedule */
+	struct list_head	schedule;
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* Register utilities
+ * NOTE:  caller must hold ohs900->lock.
+ */
+
+static inline u8 ohs900_read(struct ohs900 *ohs900, int reg)
+{
+	u8 temp;
+
+	temp = ( (volatile int *) ohs900->addr_reg) [reg];
+
+	return temp;
+}
+
+static inline void ohs900_write(struct ohs900 *ohs900, int reg, u8 val)
+{
+	( (volatile int *) ohs900->addr_reg) [reg] = val;
+}
+
+static inline void
+ohs900_write_buf(struct ohs900 *ohs900, int addr, const void *buf, size_t count)
+{
+    void __iomem *addr_reg = ohs900->addr_reg;
+	const u8	*data;
+	const u8	*tempData;
+	size_t tempCnt;
+	
+	if (!count)
+		return;
+
+	//printk("ohs900_write_buf(): Writing 0x%x bytes:\n", count);
+	tempData = buf;
+	tempCnt = count;
+	do {
+		//printk("0x%02x ", *tempData++);
+	} while (--tempCnt);
+	//printk("\n");
+
+	data = buf;
+	do {
+		( (int *) addr_reg) [addr] = *data++;
+	} while (--count);
+
+
+}
+
+static inline void
+ohs900_read_buf(struct ohs900 *ohs900, int addr, void *buf, size_t count)
+{
+    void __iomem *addr_reg = ohs900->addr_reg;
+	u8 		*data;
+	u8 		*tempData;
+	size_t		tempCnt;
+
+	if (!count)
+		return;
+
+	data = buf;
+	tempData = buf;
+	tempCnt = count;
+	//printk("ohs900_read_buf(): Reading 0x%x bytes\n", count);
+	do {
+		//*data++ = ( (int *) OHS900_BASE) [addr];
+		*data++ = ( (int *) addr_reg) [addr];
+	} while (--count);
+
+	do {
+		//printk("0x%02x ",*tempData++);
+	} while (--tempCnt);
+	//printk("\n");
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef DEBUG
+#define DBG(stuff...)		printk(KERN_DEBUG "ohs900: " stuff)
+#else
+#define DBG(stuff...)		do{}while(0)
+#endif
+
+#ifdef VERBOSE
+#    define VDBG		DBG
+#else
+#    define VDBG(stuff...)	do{}while(0)
+#endif
+
+#ifdef PACKET_TRACE
+#    define PACKET		VDBG
+#else
+#    define PACKET(stuff...)	do{}while(0)
+#endif
+
+#define ERR(stuff...)		printk(KERN_ERR "ohs900: " stuff)
+#define WARNING(stuff...)	printk(KERN_WARNING "ohs900: " stuff)
+#define INFO(stuff...)		printk(KERN_INFO "ohs900: " stuff)
+

--- host.old/ohs900-hcd.c	1970-01-01 01:00:00.000000000 +0100
+++ host/ohs900-hcd.c	2008-12-01 16:46:00.000000000 +0100
@@ -0,0 +1,1831 @@
+/*
+ * OHS900 HCD (Host Controller Driver) for USB.
+ *
+ * Based on David Brownell's SL811 HCD
+ *
+ * Copyright (C) 2005 Steve Fielding
+ * Copyright (C) 2004 Psion Teklogix (for NetBook PRO)
+ * Copyright (C) 2004-2005 David Brownell
+ * 
+ * Periodic scheduling is based on Roman's OHCI code
+ * 	Copyright (C) 1999 Roman Weissgaerber
+ *
+ * The OHS900 controller handles host side USB 
+ * as well as peripheral side USB
+ * This driver version doesn't implement the Gadget API
+ * for the peripheral role.
+ *
+ * For documentation, see the OHS900 spec.
+ *
+ * Further changes for 2.6.22.1 kernel by Mario Becroft and Bryce Smith
+ */ 
+
+/*
+ * Status:  Passed basic testing, works with usb-storage.
+ *
+ * TODO:
+ * - Replace direct memory accesses.
+ * - various issues noted in the code
+ * - use urb->iso_frame_desc[] with ISO transfers
+ */
+
+//#undef	VERBOSE
+//#undef	PACKET_TRACE
+
+/*#define DEBUG*/
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/usb.h>
+#include <linux/usb_ohs900.h>
+#include <linux/platform_device.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+
+#include "../core/hcd.h"
+#include "ohs900.h"
+
+
+MODULE_DESCRIPTION("OHS900 USB Host Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ohs900-hcd");
+
+#define DRIVER_VERSION	"19 Sep 2007"
+
+
+#ifndef DEBUG
+#	define	STUB_DEBUG_FILE
+#endif
+
+/* Disable the debug file since it broken at present */
+#define STUB_DEBUG_FILE
+
+/* for now, use only one transfer register bank */
+#undef	USE_B
+
+/* this doesn't understand urb->iso_frame_desc[], but if you had a driver
+ * that just queued one ISO frame per URB then iso transfers "should" work
+ * using the normal urb status fields.
+ */
+#define	DISABLE_ISO
+
+// #define	QUIRK2
+#define	QUIRK3
+
+static const char hcd_name[] = "ohs900-hcd";
+
+void ohs900_release(struct device *dev);
+
+/*-------------------------------------------------------------------------*/
+
+static irqreturn_t ohs900h_irq(struct usb_hcd *hcd);
+
+static void port_power(struct ohs900 *ohs900, int is_on)
+{
+	struct usb_hcd	*hcd = ohs900_to_hcd(ohs900);
+	u8			tmp;
+
+	printk(KERN_INFO "IRQ!\n");
+	INFO("driver %s, ohs900->addr_reg = 0x%x, OHS900_HWREVREG = 0x%x\n", 
+			hcd_name, (unsigned int) ohs900->addr_reg, OHS900_HWREVREG);
+	tmp = ohs900_read(ohs900, OHS900_HWREVREG);
+	INFO("driver %s, started port_power, usb hw version = %d\n", hcd_name, tmp);
+
+	/* hub is inactive unless the port is powered */
+	if (is_on) {
+		if (ohs900->port1 & (1 << USB_PORT_FEAT_POWER))
+			return;
+
+		ohs900->port1 = (1 << USB_PORT_FEAT_POWER);
+		ohs900->irq_enable = OHS900_INTMASK_INSRMV;
+	} else {
+		ohs900->port1 = 0;
+		ohs900->irq_enable = 0;
+		hcd->state = HC_STATE_HALT;
+	}
+
+	INFO("driver %s, setting ohs900->ctrl1\n", hcd_name);
+	ohs900->ctrl1 = OHS900_TXLCTL_MASK_FS_RATE & OHS900_TXLCTL_MASK_FS_POL;
+
+	INFO("driver %s, disabling interrupts\n", hcd_name);
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, 0);
+
+	INFO("driver %s, clearing interrupt status\n", hcd_name);
+	ohs900_write(ohs900, OHS900_IRQ_STATUS, ~0);
+
+	if (ohs900->board && ohs900->board->port_power) {
+		/* switch VBUS, at 500mA unless hub power budget gets set */
+		DBG("power %s\n", is_on ? "on" : "off");
+		ohs900->board->port_power(hcd->self.controller, is_on);
+	}
+
+	/* reset as thoroughly as we can */
+	if (ohs900->board && ohs900->board->reset)
+		ohs900->board->reset(hcd->self.controller);
+
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, 0);
+	ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+
+	ohs900_write(ohs900, OHS900_SOFENREG, 0);
+	ohs900_write(ohs900, OHS900_HOSTSLAVECTLREG, OHS900_HS_CTL_INIT);
+
+	INFO("driver %s, OHS900_IRQ_ENABLE = %d\n", hcd_name, ohs900->irq_enable);
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, ohs900->irq_enable);
+
+	// if !is_on, put into lowpower mode now
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* This is a PIO-only HCD.  Queueing appends URBs to the endpoint's queue,
+ * and may start I/O.  Endpoint queues are scanned during completion irq
+ * handlers (one per packet: ACK, NAK, faults, etc) and urb cancelation.
+ *
+ * Using an external DMA engine to copy a packet at a time could work,
+ * though setup/teardown costs may be too big to make it worthwhile.
+ */
+
+/* SETUP starts a new control request.  Devices are not allowed to
+ * STALL or NAK these; they must cancel any pending control requests.
+ */
+static void setup_packet(
+	struct ohs900		*ohs900,
+	struct ohs900h_ep	*ep,
+	struct urb		*urb,
+	u8			control
+)
+{
+	u8			addr;
+	u8			len;
+
+	ohs900_write(ohs900, OHS900_TXFIFOCONTROLREG, OHS900_FIFO_FORCE_EMPTY);
+	addr = OHS900_HOST_TXFIFO_DATA;
+	len = sizeof(struct usb_ctrlrequest);
+	ohs900_write_buf(ohs900, addr, urb->setup_packet, len);
+
+	ohs900_write(ohs900, OHS900_TXTRANSTYPEREG, OHS900_SETUP);
+	ohs900_write(ohs900, OHS900_TXENDPREG, 0 /* ep->epnum */ );
+	ohs900_write(ohs900, OHS900_TXADDRREG, usb_pipedevice(urb->pipe));
+
+	/* always OUT/data0 */ ;
+	ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, control);
+	ep->length = 0;
+	PACKET("SETUP qh%p\n", ep);
+}
+
+/* STATUS finishes control requests, often after IN or OUT data packets */
+static void status_packet(
+	struct ohs900		*ohs900,
+	struct ohs900h_ep	*ep,
+	struct urb		*urb,
+	u8			control
+)
+{
+	int			do_out;
+
+	do_out = urb->transfer_buffer_length && usb_pipein(urb->pipe);
+
+	ohs900_write(ohs900, OHS900_TXTRANSTYPEREG, (do_out ? OHS900_OUT_DATA1 : OHS900_IN));
+	ohs900_write(ohs900, OHS900_TXENDPREG, 0 /* ep->epnum */ );
+	ohs900_write(ohs900, OHS900_TXADDRREG, usb_pipedevice(urb->pipe));
+
+	/* always data1; sometimes IN */
+	ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, control);
+	ep->length = 0;
+	PACKET("STATUS%s/%s qh%p\n", ep->nak_count ? "/retry" : "",
+			do_out ? "out" : "in", ep);
+}
+
+/* IN packets can be used with any type of endpoint. here we just
+ * start the transfer, data from the peripheral may arrive later.
+ * urb->iso_frame_desc is currently ignored here...
+ */
+static void in_packet(
+	struct ohs900		*ohs900,
+	struct ohs900h_ep	*ep,
+	struct urb		*urb,
+	u8			control
+)
+{
+	u8			len;
+
+	/* avoid losing data on overflow */
+	len = ep->maxpacket;
+
+
+	ohs900_write(ohs900, OHS900_RXFIFOCONTROLREG, OHS900_FIFO_FORCE_EMPTY);
+	ohs900_write(ohs900, OHS900_TXTRANSTYPEREG, OHS900_IN);
+	ohs900_write(ohs900, OHS900_TXADDRREG, usb_pipedevice(urb->pipe));
+	ohs900_write(ohs900, OHS900_TXENDPREG, ep->epnum);
+	ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, control);
+	ep->length = min((int)len,
+			urb->transfer_buffer_length - urb->actual_length);
+	PACKET("IN%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",
+			!!usb_gettoggle(urb->dev, ep->epnum, 0), ep, len);
+}
+
+/* OUT packets can be used with any type of endpoint.
+ * urb->iso_frame_desc is currently ignored here...
+ */
+static void out_packet(
+	struct ohs900		*ohs900,
+	struct ohs900h_ep	*ep,
+	struct urb		*urb,
+	u8			control
+)
+{
+	void			*buf;
+	u8			len;
+
+	buf = urb->transfer_buffer + urb->actual_length;
+	prefetch(buf);
+
+	len = min((int)ep->maxpacket,
+			urb->transfer_buffer_length - urb->actual_length);
+
+	ohs900_write(ohs900, OHS900_TXFIFOCONTROLREG, OHS900_FIFO_FORCE_EMPTY);
+	if (!(control & OHS900_HCTLMASK_ISO_EN)
+			&& usb_gettoggle(urb->dev, ep->epnum, 1))
+		ohs900_write(ohs900, OHS900_TXTRANSTYPEREG, OHS900_OUT_DATA1);
+	else
+		ohs900_write(ohs900, OHS900_TXTRANSTYPEREG, OHS900_OUT_DATA0);
+
+
+	ohs900_write_buf(ohs900, OHS900_HOST_TXFIFO_DATA, buf, len);
+
+	ohs900_write(ohs900, OHS900_TXADDRREG, usb_pipedevice(urb->pipe));
+	ohs900_write(ohs900, OHS900_TXENDPREG, ep->epnum);
+	ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, control);
+
+	ep->length = len;
+	PACKET("OUT%s/%d qh%p len%d\n", ep->nak_count ? "/retry" : "",
+			!!usb_gettoggle(urb->dev, ep->epnum, 1), ep, len);
+}
+/*-------------------------------------------------------------------------*/
+
+/* caller updates on-chip enables later */
+
+static inline void sofirq_on(struct ohs900 *ohs900)
+{
+	if (ohs900->irq_enable & OHS900_INTMASK_SOFINTR)
+		return;
+	VDBG("sof irq on\n");
+	ohs900->irq_enable |= OHS900_INTMASK_SOFINTR;
+}
+
+static inline void sofirq_off(struct ohs900 *ohs900)
+{
+	if (!(ohs900->irq_enable & OHS900_INTMASK_SOFINTR))
+		return;
+	VDBG("sof irq off\n");
+	ohs900->irq_enable &= ~OHS900_INTMASK_SOFINTR;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* pick the next endpoint for a transaction, and issue it.
+ * frames start with periodic transfers (after whatever is pending
+ * from the previous frame), and the rest of the time is async
+ * transfers, scheduled round-robin.
+ */
+static struct ohs900h_ep	*start(struct ohs900 *ohs900)
+{
+	struct ohs900h_ep	*ep;
+	struct urb		*urb;
+	int			fclock;
+	u8			control;
+
+	/* use endpoint at schedule head */
+	if (ohs900->next_periodic) {
+		ep = ohs900->next_periodic;
+		ohs900->next_periodic = ep->next;
+	} else {
+		if (ohs900->next_async)
+			ep = ohs900->next_async;
+		else if (!list_empty(&ohs900->async))
+			ep = container_of(ohs900->async.next,
+					struct ohs900h_ep, schedule);
+		else {
+			/* could set up the first fullspeed periodic
+			 * transfer for the next frame ...
+			 */
+			return NULL;
+		}
+
+
+
+
+
+
+		if (ep->schedule.next == &ohs900->async)
+			ohs900->next_async = NULL;
+		else
+			ohs900->next_async = container_of(ep->schedule.next,
+					struct ohs900h_ep, schedule);
+	}
+
+	if (unlikely(list_empty(&ep->hep->urb_list))) {
+		DBG("empty %p queue?\n", ep);
+		return NULL;
+	}
+
+	urb = container_of(ep->hep->urb_list.next, struct urb, urb_list);
+	control = ep->defctrl;
+
+	/* if this frame doesn't have enough time left to transfer this
+	 * packet, wait till the next frame.  too-simple algorithm...
+	 */
+	fclock = 12000 - (ohs900_read(ohs900, OHS900_SOFTMRREG) << 6);
+	fclock -= 100;		/* setup takes not much time */
+	fclock -= 1500; /* Margin to workaround too-long-frame bug */
+	if (urb->dev->speed == USB_SPEED_LOW) {
+		if (control & OHS900_HCTLMASK_PREAMBLE_EN) {
+			/* also note erratum 1: some hubs won't work */
+			fclock -= 800;
+		}
+		fclock -= ep->maxpacket << 8;
+
+		/* erratum 2: AFTERSOF only works for fullspeed */
+		if (fclock < 0) {
+			if (ep->period)
+				ohs900->stat_overrun++;
+			sofirq_on(ohs900);
+			return NULL;
+		}
+	} else {
+		fclock -= 12000 / 19;	/* 19 64byte packets/msec */
+		if (fclock < 0) {
+			if (ep->period)
+				ohs900->stat_overrun++;
+			control |= OHS900_HCTLMASK_SOF_SYNC;
+
+		/* throttle bulk/control irq noise */
+		} else if (ep->nak_count)
+			control |= OHS900_HCTLMASK_SOF_SYNC;
+	}
+
+
+	switch (ep->nextpid) {
+	case USB_PID_IN:
+		in_packet(ohs900, ep, urb, control);
+		break;
+	case USB_PID_OUT:
+		out_packet(ohs900, ep, urb, control);
+		break;
+	case USB_PID_SETUP:
+		setup_packet(ohs900, ep, urb, control);
+		break;
+	case USB_PID_ACK:		/* for control status */
+		status_packet(ohs900, ep, urb, control);
+		break;
+	default:
+		DBG("bad ep%p pid %02x\n", ep, ep->nextpid);
+		ep = NULL;
+	}
+	return ep;
+}
+
+#define MIN_JIFFIES	((msecs_to_jiffies(2) > 1) ? msecs_to_jiffies(2) : 2)
+
+static inline void start_transfer(struct ohs900 *ohs900)
+{
+	if (ohs900->port1 & (1 << USB_PORT_FEAT_SUSPEND))
+		return;
+	if (ohs900->active_a == NULL) {
+		ohs900->active_a = start(ohs900);
+		if (ohs900->active_a != NULL)
+			ohs900->jiffies_a = jiffies + MIN_JIFFIES;
+	}
+}
+
+static void finish_request(
+	struct ohs900		*ohs900,
+	struct ohs900h_ep	*ep,
+	struct urb		*urb,
+	int			status
+) __releases(ohs900->lock) __acquires(ohs900->lock)
+{
+	unsigned		i;
+
+	urb->hcpriv = NULL;
+
+	if (usb_pipecontrol(urb->pipe))
+		ep->nextpid = USB_PID_SETUP;
+
+	usb_hcd_unlink_urb_from_ep(ohs900_to_hcd(ohs900),urb);
+	spin_unlock(&ohs900->lock);
+	usb_hcd_giveback_urb(ohs900_to_hcd(ohs900), urb, status);
+	spin_lock(&ohs900->lock);
+
+	/* leave active endpoints in the schedule */
+	if (!list_empty(&ep->hep->urb_list))
+		return;
+
+	/* async deschedule? */
+	if (!list_empty(&ep->schedule)) {
+		list_del_init(&ep->schedule);
+		if (ep == ohs900->next_async)
+			ohs900->next_async = NULL;
+		return;
+	}
+
+	/* periodic deschedule */
+	DBG("deschedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+	for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
+		struct ohs900h_ep	*temp;
+		struct ohs900h_ep	**prev = &ohs900->periodic[i];
+
+		while (*prev && ((temp = *prev) != ep))
+			prev = &temp->next;
+		if (*prev)
+			*prev = ep->next;
+		ohs900->load[i] -= ep->load;
+	}	
+	ep->branch = PERIODIC_SIZE;
+	ohs900->periodic_count--;
+	ohs900_to_hcd(ohs900)->self.bandwidth_allocated
+		-= ep->load / ep->period;
+	if (ep == ohs900->next_periodic)
+		ohs900->next_periodic = ep->next;
+
+	/* we might turn SOFs back on again for the async schedule */
+	if (ohs900->periodic_count == 0)
+		sofirq_off(ohs900);
+}
+
+static void
+done(struct ohs900 *ohs900, struct ohs900h_ep *ep)
+{
+	u8			status;
+	struct urb		*urb;
+	int			urbstat = -EINPROGRESS;
+
+	if (unlikely(!ep))
+		return;
+
+	status = ohs900_read(ohs900, OHS900_HRXSTATREG);
+
+	urb = container_of(ep->hep->urb_list.next, struct urb, urb_list);
+
+	/* we can safely ignore NAKs */
+	if (status & OHS900_STATMASK_NAK_RXED) {
+		// PACKET("...NAK qh%p\n", ep);
+		if (!ep->period)
+			ep->nak_count++;
+		ep->error_count = 0;
+
+	/* ACK, or IN with no errors, advances transfer, toggle, and maybe queue */
+	} else if (status & OHS900_STATMASK_ACK_RXED
+			|| ((status & ~OHS900_STATMASK_DATA_SEQ) == 0) ) {
+		struct usb_device	*udev = urb->dev;
+		int			len;
+		unsigned char		*buf;
+
+		/* urb->iso_frame_desc is currently ignored here... */
+
+		ep->nak_count = ep->error_count = 0;
+		switch (ep->nextpid) {
+		case USB_PID_OUT:
+			// PACKET("...ACK/out qh%p\n", ep);
+			urb->actual_length += ep->length;
+			usb_dotoggle(udev, ep->epnum, 1);
+			if (urb->actual_length
+					== urb->transfer_buffer_length) {
+				if (usb_pipecontrol(urb->pipe))
+					ep->nextpid = USB_PID_ACK;
+
+				/* some bulk protocols terminate OUT transfers
+				 * by a short packet, using ZLPs not padding.
+				 */
+				else if (ep->length < ep->maxpacket
+						|| !(urb->transfer_flags
+							& URB_ZERO_PACKET))
+					urbstat = 0;
+			}
+			break;
+		case USB_PID_IN:
+			// PACKET("...ACK/in qh%p\n", ep);
+			buf = urb->transfer_buffer + urb->actual_length;
+			prefetchw(buf);
+			len = ohs900_read(ohs900, OHS900_RXFIFOCNTLSBREG) 
+					+ (ohs900_read(ohs900,
+					OHS900_RXFIFOCNTMSBREG) << 8);
+			
+			if (len > ep->length) {
+				len = ep->length;
+				urbstat = -EOVERFLOW;
+			}
+			urb->actual_length += len;
+			ohs900_read_buf(ohs900, OHS900_HOST_RXFIFO_DATA,
+					buf, len);
+			usb_dotoggle(udev, ep->epnum, 0);
+			if (urbstat == -EINPROGRESS &&
+				(len < ep->maxpacket ||
+					urb->actual_length ==
+					urb->transfer_buffer_length)) {
+				if (usb_pipecontrol(urb->pipe))
+					ep->nextpid = USB_PID_ACK;
+				else
+					urbstat = 0;
+			}
+			break;
+		case USB_PID_SETUP:
+			// PACKET("...ACK/setup qh%p\n", ep);
+			if (urb->transfer_buffer_length == urb->actual_length)
+				ep->nextpid = USB_PID_ACK;
+			else if (usb_pipeout(urb->pipe)) {
+				usb_settoggle(udev, 0, 1, 1);
+				ep->nextpid = USB_PID_OUT;
+			} else {
+				usb_settoggle(udev, 0, 0, 1);
+				ep->nextpid = USB_PID_IN;
+			}
+			break;
+		case USB_PID_ACK:
+			// PACKET("...ACK/status qh%p\n", ep);
+			urbstat = 0;
+			break;
+		}
+
+	/* STALL stops all transfers */
+	} else if (status & OHS900_STATMASK_STALL_RXED) {
+		PACKET("...STALL qh%p\n", ep);
+		ep->nak_count = ep->error_count = 0;
+		urbstat = -EPIPE;
+
+	/* error? retry, until "3 strikes" */
+	} else if (++ep->error_count >= 3) {
+		if (status & OHS900_STATMASK_RX_TMOUT)
+			urbstat = -ETIME;
+		else if (status & OHS900_STATMASK_RX_OVF)
+			urbstat = -EOVERFLOW;
+		else
+			urbstat = -EPROTO;
+		ep->error_count = 0;
+		PACKET("...3STRIKES %02x qh%p stat %d\n",
+				status, ep, urbstat);
+	}
+
+	if (urbstat != -EINPROGRESS || urb->unlinked)
+		finish_request(ohs900, ep, urb, urbstat);
+}
+
+static inline u8 checkdone(struct ohs900 *ohs900)
+{
+	u8	ctl;
+	u8	irqstat = 0;
+
+	if (ohs900->active_a && time_before_eq(ohs900->jiffies_a, jiffies)) {
+		ctl = ohs900_read(ohs900, OHS900_HOST_TX_CTLREG);
+		if (ctl & OHS900_HCTLMASK_TRANS_REQ)
+			ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, 0);
+		DBG("%s DONE_A: ctrl %02x sts %02x\n",
+			(ctl & OHS900_HCTLMASK_TRANS_REQ) ? "timeout" : "lost",
+			ctl,
+			ohs900_read(ohs900, OHS900_HRXSTATREG));
+		irqstat |= OHS900_INTMASK_TRANS_DONE;
+	}
+	return irqstat;
+}
+
+static irqreturn_t ohs900h_irq(struct usb_hcd *hcd)
+{
+	struct ohs900	*ohs900 = hcd_to_ohs900(hcd);
+	u8		irqstat;
+	irqreturn_t	ret = IRQ_NONE;
+	unsigned	retries = 5;
+
+	//printk("Entering ohs900h_irq\n");
+	spin_lock(&ohs900->lock);
+
+retry:
+	irqstat = ohs900_read(ohs900, OHS900_IRQ_STATUS);
+	if (irqstat) {
+		ohs900_write(ohs900, OHS900_IRQ_STATUS, irqstat);
+		irqstat &= ohs900->irq_enable;
+	}
+
+#ifdef	QUIRK2
+	/* this may no longer be necessary ... */
+	if (irqstat == 0) {
+		irqstat = checkdone(ohs900);
+		if (irqstat)
+			ohs900->stat_lost++;
+	}
+#endif
+
+	/* USB packets, not necessarily handled in the order they're
+	 * issued ... that's fine if they're different endpoints.
+	 */
+	if (irqstat & OHS900_INTMASK_TRANS_DONE) {
+		done(ohs900, ohs900->active_a);
+		ohs900->active_a = NULL;
+		ohs900->stat_a++;
+	}
+
+
+	if (irqstat & OHS900_INTMASK_SOFINTR) {
+		unsigned index;
+
+		index = ohs900->frame++ % (PERIODIC_SIZE - 1);
+		ohs900->stat_sof++;
+
+		/* be graceful about almost-inevitable periodic schedule
+		 * overruns:  continue the previous frame's transfers iff
+		 * this one has nothing scheduled.
+		 */
+		if (ohs900->next_periodic) {
+			// ERR("overrun to slot %d\n", index);
+			ohs900->stat_overrun++;
+		}
+		if (ohs900->periodic[index])
+			ohs900->next_periodic = ohs900->periodic[index];
+	}
+
+	/* khubd manages debouncing and wakeup */
+	if (irqstat & OHS900_INTMASK_INSRMV) {
+		ohs900->stat_insrmv++;
+
+		/* most stats are reset for each VBUS session */
+		ohs900->stat_wake = 0;
+		ohs900->stat_sof = 0;
+		ohs900->stat_a = 0;
+		ohs900->stat_b = 0;
+		ohs900->stat_lost = 0;
+
+		ohs900->ctrl1 = 0;
+		ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+
+		ohs900->irq_enable = OHS900_INTMASK_INSRMV;
+		ohs900_write(ohs900, OHS900_IRQ_ENABLE, ohs900->irq_enable);
+
+		/* usbcore nukes other pending transactions on disconnect */
+		if (ohs900->active_a) {
+			ohs900_write(ohs900, OHS900_HOST_TX_CTLREG, 0);
+			finish_request(ohs900, ohs900->active_a,
+				container_of(ohs900->active_a
+					     ->hep->urb_list.next,
+					     struct urb, urb_list),
+				       -ESHUTDOWN);
+			ohs900->active_a = NULL;
+		}
+
+
+		/* port status seems wierd until after reset, so
+		 * force the reset and make khubd clean up later.
+		 */
+		ohs900->port1 |= (1 << USB_PORT_FEAT_C_CONNECTION)
+				| (1 << USB_PORT_FEAT_CONNECTION);
+
+	} else if (irqstat & OHS900_INTMASK_RESUME_DET) {
+		if (ohs900->port1 & (1 << USB_PORT_FEAT_SUSPEND)) {
+			DBG("wakeup\n");
+			ohs900->port1 |= 1 << USB_PORT_FEAT_C_SUSPEND;
+			ohs900->stat_wake++;
+		} else
+			irqstat &= ~OHS900_INTMASK_RESUME_DET;
+	}
+
+	if (irqstat) {
+		if (ohs900->port1 & (1 << USB_PORT_FEAT_ENABLE))
+			start_transfer(ohs900);
+		ret = IRQ_HANDLED;
+		if (retries--)
+			goto retry;
+	}
+
+	if (ohs900->periodic_count == 0 && list_empty(&ohs900->async)) 
+		sofirq_off(ohs900);
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, ohs900->irq_enable);
+
+	spin_unlock(&ohs900->lock);
+
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* usb 1.1 says max 90% of a frame is available for periodic transfers.
+ * this driver doesn't promise that much since it's got to handle an
+ * IRQ per packet; irq handling latencies also use up that time.
+ */
+#define	MAX_PERIODIC_LOAD	500	/* out of 1000 usec */
+
+static int balance(struct ohs900 *ohs900, u16 period, u16 load)
+{
+	int	i, branch = -ENOSPC;
+
+	/* search for the least loaded schedule branch of that period
+	 * which has enough bandwidth left unreserved.
+	 */
+	for (i = 0; i < period ; i++) {
+		if (branch < 0 || ohs900->load[branch] > ohs900->load[i]) {
+			int	j;
+
+			for (j = i; j < PERIODIC_SIZE; j += period) {
+				if ((ohs900->load[j] + load)
+						> MAX_PERIODIC_LOAD)
+					break;
+			}
+			if (j < PERIODIC_SIZE)
+				continue;
+			branch = i; 
+		}
+	}
+	return branch;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int ohs900h_urb_enqueue(
+	struct usb_hcd	    *hcd,
+	struct urb	    *urb,
+	gfp_t		    mem_flags
+) {
+	struct ohs900		*ohs900 = hcd_to_ohs900(hcd);
+	struct usb_device	*udev = urb->dev;
+	unsigned int		pipe = urb->pipe;
+	int			is_out = !usb_pipein(pipe);
+	int			type = usb_pipetype(pipe);
+	int			epnum = usb_pipeendpoint(pipe);
+	struct ohs900h_ep	*ep = NULL;
+	unsigned long		flags;
+	int			i;
+	int			retval;
+	struct usb_host_endpoint	*hep = urb->ep;
+
+#ifdef	DISABLE_ISO
+	if (type == PIPE_ISOCHRONOUS)
+		return -ENOSPC;
+#endif
+
+	/* avoid all allocations within spinlocks */
+	if (!hep->hcpriv)
+	  ep = kzalloc(sizeof *ep, mem_flags);
+
+	spin_lock_irqsave(&ohs900->lock, flags);
+
+	/* don't submit to a dead or disabled port */
+	if (!(ohs900->port1 & (1 << USB_PORT_FEAT_ENABLE))
+			|| !HC_IS_RUNNING(hcd->state)) {
+		retval = -ENODEV;
+		kfree(ep);
+		goto fail_not_linked;
+	}
+	retval = usb_hcd_link_urb_to_ep(hcd, urb);
+	if (retval) {
+		kfree(ep);
+		goto fail_not_linked;
+	}
+
+	if (hep->hcpriv) {
+		ep = hep->hcpriv;
+	} else if (!ep) {
+		retval = -ENOMEM;
+		goto fail;
+
+	} else {
+		INIT_LIST_HEAD(&ep->schedule);
+		ep->udev = udev;
+		ep->epnum = epnum;
+		ep->maxpacket = usb_maxpacket(udev, urb->pipe, is_out);
+		ep->defctrl = OHS900_HCTLMASK_TRANS_REQ;
+		usb_settoggle(udev, epnum, is_out, 0);
+
+		if (type == PIPE_CONTROL)
+			ep->nextpid = USB_PID_SETUP;
+		else if (is_out)
+			ep->nextpid = USB_PID_OUT;
+		else
+			ep->nextpid = USB_PID_IN;
+
+		if (ep->maxpacket > H_MAXPACKET) {
+			/* iso packets up to 64 bytes could work... */
+			DBG("dev %d ep%d maxpacket %d\n",
+				udev->devnum, epnum, ep->maxpacket);
+			retval = -EINVAL;
+			goto fail;
+		}
+
+		if (udev->speed == USB_SPEED_LOW) {
+			/* send preamble for external hub? */
+			if (ohs900->ctrl1 & OHS900_TXLCTL_MASK_FS_RATE)
+				ep->defctrl |= OHS900_HCTLMASK_PREAMBLE_EN;
+		}
+		switch (type) {
+		case PIPE_ISOCHRONOUS:
+		case PIPE_INTERRUPT:
+			if (urb->interval > PERIODIC_SIZE)
+				urb->interval = PERIODIC_SIZE;
+			ep->period = urb->interval;
+			ep->branch = PERIODIC_SIZE;
+			if (type == PIPE_ISOCHRONOUS)
+				ep->defctrl |= OHS900_HCTLMASK_ISO_EN;
+			ep->load = usb_calc_bus_time(udev->speed, !is_out,
+				(type == PIPE_ISOCHRONOUS),
+				usb_maxpacket(udev, pipe, is_out))
+					/ 1000;
+			break;
+		}
+
+		hep->hcpriv = ep;
+		ep->hep = hep;
+	}
+
+	/* maybe put endpoint into schedule */
+	switch (type) {
+	case PIPE_CONTROL:
+	case PIPE_BULK:
+		if (list_empty(&ep->schedule))
+			list_add_tail(&ep->schedule, &ohs900->async);
+		break;
+	case PIPE_ISOCHRONOUS:
+	case PIPE_INTERRUPT:
+		urb->interval = ep->period;
+		if (ep->branch < PERIODIC_SIZE)
+			break;
+
+		retval = balance(ohs900, ep->period, ep->load);
+		if (retval < 0)
+			goto fail;
+		ep->branch = retval;
+		retval = 0;
+		urb->start_frame = (ohs900->frame & (PERIODIC_SIZE - 1))
+					+ ep->branch;
+
+		/* sort each schedule branch by period (slow before fast)
+		 * to share the faster parts of the tree without needing
+		 * dummy/placeholder nodes
+		 */
+		DBG("schedule qh%d/%p branch %d\n", ep->period, ep, ep->branch);
+		for (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {
+			struct ohs900h_ep	**prev = &ohs900->periodic[i];
+			struct ohs900h_ep	*here = *prev;
+
+			while (here && ep != here) {
+				if (ep->period > here->period)
+					break;
+				prev = &here->next;
+				here = *prev;
+			}
+			if (ep != here) {
+				ep->next = here;
+				*prev = ep;
+			}
+			ohs900->load[i] += ep->load;
+		}
+		ohs900->periodic_count++;
+		hcd->self.bandwidth_allocated += ep->load / ep->period;
+		sofirq_on(ohs900);
+	}
+
+	urb->hcpriv = hep;
+
+	start_transfer(ohs900);
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, ohs900->irq_enable);
+fail:
+	if (retval)
+		usb_hcd_unlink_urb_from_ep(hcd,urb);
+fail_not_linked:
+	spin_unlock_irqrestore(&ohs900->lock, flags);
+	return retval;
+}
+
+static int ohs900h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct ohs900		*ohs900 = hcd_to_ohs900(hcd);
+	struct usb_host_endpoint *hep;
+	unsigned long		flags;
+	struct ohs900h_ep	*ep;
+	int			retval;
+
+	spin_lock_irqsave(&ohs900->lock, flags);
+	retval = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (retval)
+		goto fail;
+
+	hep = hep->hcpriv;
+	if (ep) {
+		/* finish right away if this urb can't be active ...
+		 * note that some drivers wrongly expect delays
+		 */
+		if (ep->hep->urb_list.next != &urb->urb_list) {
+			/* not front of queue?  never active */
+
+		/* for active transfers, we expect an IRQ */
+		} else if (ohs900->active_a == ep) {
+			if (time_before_eq(ohs900->jiffies_a, jiffies)) {
+				/* happens a lot with lowspeed?? */
+				DBG("giveup on DONE_A: ctrl %02x sts %02x\n",
+					ohs900_read(ohs900,OHS900_HOST_TX_CTLREG),
+					ohs900_read(ohs900,OHS900_HRXSTATREG));
+				ohs900_write(ohs900, OHS900_HOST_TX_CTLREG,0);
+				ohs900->active_a = NULL;
+			} else
+				urb = NULL;
+
+		} else {
+			/* front of queue for inactive endpoint */
+		}
+
+		if (urb)
+			finish_request(ohs900, ep, urb, 0);
+		else
+			VDBG("dequeue, urb %p active %s; wait4irq\n", urb,
+				(ohs900->active_a == ep) ? "A" : "B");
+	} else
+	  
+fail:
+	spin_unlock_irqrestore(&ohs900->lock, flags);
+	return retval;
+}
+
+static void
+ohs900h_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
+{
+	struct ohs900h_ep	*ep = hep->hcpriv;
+
+	if (!ep)
+		return;
+
+	/* assume we'd just wait for the irq */
+	if (!list_empty(&hep->urb_list))
+	    msleep(3);
+	if (!list_empty(&hep->urb_list))
+	    WARNING("ep %p not empty?\n", ep);
+
+	kfree(ep);
+	hep->hcpriv = NULL;
+}
+
+static int
+ohs900h_get_frame(struct usb_hcd *hcd)
+{
+	struct ohs900 *ohs900 = hcd_to_ohs900(hcd);
+
+	/* wrong except while periodic transfers are scheduled;
+	 * never matches the on-the-wire frame;
+	 * subject to overruns.
+	 */
+	return ohs900->frame;
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/* the virtual root hub timer IRQ checks for hub status */
+static int
+ohs900h_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct ohs900 *ohs900 = hcd_to_ohs900(hcd);
+#ifdef	QUIRK3
+	unsigned long flags;
+
+	/* non-SMP HACK: use root hub timer as i/o watchdog
+	 * this seems essential when SOF IRQs aren't in use...
+	 */
+	local_irq_save(flags);
+	if (!timer_pending(&ohs900->timer)) {
+		if (ohs900h_irq( /* ~0, */ hcd) != IRQ_NONE)
+			ohs900->stat_lost++;
+	}
+	local_irq_restore(flags);
+#endif
+
+	if (!(ohs900->port1 & (0xffff << 16)))
+		return 0;
+
+	/* tell khubd port 1 changed */
+	*buf = (1 << 1);
+	return 1;
+}
+
+static void
+ohs900h_hub_descriptor (
+	struct ohs900			*ohs900,
+	struct usb_hub_descriptor	*desc
+) {
+	u16		temp = 0;
+
+	desc->bDescriptorType = 0x29;
+	desc->bHubContrCurrent = 0;
+
+	desc->bNbrPorts = 1;
+	desc->bDescLength = 9;
+
+	/* per-port power switching (gang of one!), or none */
+	desc->bPwrOn2PwrGood = 0;
+	if (ohs900->board && ohs900->board->port_power) {
+		desc->bPwrOn2PwrGood = ohs900->board->potpg;
+		if (!desc->bPwrOn2PwrGood)
+			desc->bPwrOn2PwrGood = 10;
+		temp = 0x0001;
+	} else
+		temp = 0x0002;
+
+	/* no overcurrent errors detection/handling */
+	temp |= 0x0010;
+
+	desc->wHubCharacteristics = cpu_to_le16(temp);
+
+	/* two bitmaps:  ports removable, and legacy PortPwrCtrlMask */
+	desc->bitmap[0] = 0 << 1;
+	desc->bitmap[1] = ~0;
+}
+
+static void
+ohs900h_timer(unsigned long _ohs900)
+{
+	struct ohs900 	*ohs900 = (void *) _ohs900;
+	unsigned long	flags;
+	u8		irqstat;
+	u8		signaling = ohs900->ctrl1 & OHS900_TXLCTL_MASK_LINE_CTRL_BITS;
+	const u32	mask = (1 << USB_PORT_FEAT_CONNECTION)
+				| (1 << USB_PORT_FEAT_ENABLE)
+				| (1 << USB_PORT_FEAT_LOWSPEED);
+	u8		sofEnReg = 0;
+
+	spin_lock_irqsave(&ohs900->lock, flags);
+
+	/* stop special signaling */
+	ohs900->ctrl1 &= ~OHS900_TXLCTL_MASK_FORCE;
+	ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+	udelay(3);
+
+	irqstat = ohs900_read(ohs900, OHS900_IRQ_STATUS);
+
+	switch (signaling) {
+	case OHS900_TXLCTL_MASK_SE0:
+		DBG("end reset\n");
+		ohs900->port1 = (1 << USB_PORT_FEAT_C_RESET)
+				| (1 << USB_PORT_FEAT_POWER);
+		ohs900->ctrl1 = 0;
+		/* don't wrongly ack RD */
+		if (irqstat & OHS900_INTMASK_INSRMV)
+			irqstat &= ~OHS900_INTMASK_RESUME_DET;
+		break;
+	case OHS900_TXLCTL_MASK_FS_K:
+		DBG("end resume\n");
+		ohs900->port1 &= ~(1 << USB_PORT_FEAT_SUSPEND);
+		break;
+	default:
+		DBG("odd timer signaling: %02x\n", signaling);
+		break;
+	}
+	ohs900_write(ohs900, OHS900_IRQ_STATUS, irqstat);
+
+	//if (irqstat & OHS900_INTMASK_RESUME_DET) {...
+	if (ohs900_read(ohs900, OHS900_RXCONNSTATEREG) == OHS900_DISCONNECT_STATE) {
+		/* usbcore nukes all pending transactions on disconnect */
+		if (ohs900->port1 & (1 << USB_PORT_FEAT_CONNECTION))
+			ohs900->port1 |= (1 << USB_PORT_FEAT_C_CONNECTION)
+					| (1 << USB_PORT_FEAT_C_ENABLE);
+		ohs900->port1 &= ~mask;
+		ohs900->irq_enable = OHS900_INTMASK_INSRMV;
+	} else {
+		ohs900->port1 |= mask;
+		if (ohs900_read(ohs900, OHS900_RXCONNSTATEREG) & OHS900_FS_CONN_STATE)
+			ohs900->port1 &= ~(1 << USB_PORT_FEAT_LOWSPEED);
+		ohs900->irq_enable = OHS900_INTMASK_INSRMV | OHS900_INTMASK_RESUME_DET;
+	}
+	//...presumably ?...}
+	if (ohs900->port1 & (1 << USB_PORT_FEAT_CONNECTION)) {
+
+		ohs900->irq_enable |= OHS900_INTMASK_TRANS_DONE;
+		if (ohs900->port1 & (1 << USB_PORT_FEAT_LOWSPEED)) {
+			ohs900->ctrl1 &= ~OHS900_TXLCTL_MASK_FS_POL;
+			ohs900->ctrl1 &= ~OHS900_TXLCTL_MASK_FS_RATE;
+		}
+		else {
+			ohs900->ctrl1 |= OHS900_TXLCTL_MASK_FS_POL;
+			ohs900->ctrl1 |= OHS900_TXLCTL_MASK_FS_RATE;
+		}
+
+		/* start SOFs flowing, kickstarting with A registers */
+		sofEnReg = OHS900_MASK_SOF_ENA;		
+
+		/* Set default device address */
+		ohs900_write(ohs900, OHS900_TXADDRREG, 0); 
+
+		/* khubd provides debounce delay */
+	} else {
+		ohs900->ctrl1 = 0;
+	}
+	ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+	ohs900_write(ohs900, OHS900_SOFENREG, sofEnReg);
+
+	/* reenable irqs */
+	ohs900_write(ohs900, OHS900_IRQ_ENABLE, ohs900->irq_enable);
+	spin_unlock_irqrestore(&ohs900->lock, flags);
+}
+
+static int
+ohs900h_hub_control(
+	struct usb_hcd	*hcd,
+	u16		typeReq,
+	u16		wValue,
+	u16		wIndex,
+	char		*buf,
+	u16		wLength
+) {
+	struct ohs900	*ohs900 = hcd_to_ohs900(hcd);
+	int		retval = 0;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&ohs900->lock, flags);
+
+	switch (typeReq) {
+	case ClearHubFeature:
+	case SetHubFeature:
+		switch (wValue) {
+		case C_HUB_OVER_CURRENT:
+		case C_HUB_LOCAL_POWER:
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		if (wIndex != 1 || wLength != 0)
+			goto error;
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			ohs900->port1 &= (1 << USB_PORT_FEAT_POWER);
+			ohs900->ctrl1 = 0;
+			ohs900_write(ohs900, OHS900_SOFENREG, 0);
+			ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+			ohs900->irq_enable = OHS900_INTMASK_INSRMV;
+			ohs900_write(ohs900, OHS900_IRQ_ENABLE,
+						ohs900->irq_enable);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			if (!(ohs900->port1 & (1 << USB_PORT_FEAT_SUSPEND)))
+				break;
+
+			/* 20 msec of resume/K signaling, other irqs blocked */
+			DBG("start resume...\n");
+			ohs900->irq_enable = 0;
+			ohs900_write(ohs900, OHS900_IRQ_ENABLE,
+						ohs900->irq_enable);
+			ohs900->ctrl1 |= OHS900_TXLCTL_MASK_FS_K;
+			ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+
+			mod_timer(&ohs900->timer, jiffies
+					+ msecs_to_jiffies(20));
+			break;
+		case USB_PORT_FEAT_POWER:
+			port_power(ohs900, 0);
+			break;
+		case USB_PORT_FEAT_C_ENABLE:
+		case USB_PORT_FEAT_C_SUSPEND:
+		case USB_PORT_FEAT_C_CONNECTION:
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+		case USB_PORT_FEAT_C_RESET:
+			break;
+		default:
+			goto error;
+		}
+		ohs900->port1 &= ~(1 << wValue);
+		break;
+	case GetHubDescriptor:
+		ohs900h_hub_descriptor(ohs900, (struct usb_hub_descriptor *) buf);
+		break;
+	case GetHubStatus:
+		*(__le32 *) buf = cpu_to_le32(0);
+		break;
+	case GetPortStatus:
+		if (wIndex != 1)
+			goto error;
+		*(__le32 *) buf = cpu_to_le32(ohs900->port1);
+
+#ifndef	VERBOSE
+	if (*(u16*)(buf+2))	/* only if wPortChange is interesting */
+#endif
+		DBG("GetPortStatus %08x\n", ohs900->port1);
+		break;
+	case SetPortFeature:
+		if (wIndex != 1 || wLength != 0)
+			goto error;
+		switch (wValue) {
+		case USB_PORT_FEAT_SUSPEND:
+			if (ohs900->port1 & (1 << USB_PORT_FEAT_RESET))
+				goto error;
+			if (!(ohs900->port1 & (1 << USB_PORT_FEAT_ENABLE)))
+				goto error;
+
+			DBG("suspend...\n");
+			ohs900_write(ohs900, OHS900_SOFENREG, 0);
+			break;
+		case USB_PORT_FEAT_POWER:
+			port_power(ohs900, 1);
+			break;
+		case USB_PORT_FEAT_RESET:
+			if (ohs900->port1 & (1 << USB_PORT_FEAT_SUSPEND))
+				goto error;
+			if (!(ohs900->port1 & (1 << USB_PORT_FEAT_POWER)))
+				break;
+
+			/* 50 msec of reset/SE0 signaling, irqs blocked */
+			ohs900->irq_enable = 0;
+			ohs900_write(ohs900, OHS900_IRQ_ENABLE,
+						ohs900->irq_enable);
+			ohs900_write(ohs900, OHS900_SOFENREG, 0);
+			ohs900->ctrl1 = OHS900_TXLCTL_MASK_SE0;
+			ohs900_write(ohs900, OHS900_TXLINECTLREG, ohs900->ctrl1);
+			ohs900->port1 |= (1 << USB_PORT_FEAT_RESET);
+			mod_timer(&ohs900->timer, jiffies
+					+ msecs_to_jiffies(50));
+			break;
+		default:
+			goto error;
+		}
+		ohs900->port1 |= 1 << wValue;
+		break;
+
+	default:
+error:
+		/* "protocol stall" on error */
+		retval = -EPIPE;
+	}
+
+	spin_unlock_irqrestore(&ohs900->lock, flags);
+	return retval;
+}
+
+#ifdef	CONFIG_PM
+
+static int
+ohs900h_bus_suspend(struct usb_hcd *hcd)
+{
+	// SOFs off
+	DBG("%s\n", __func__);
+	return 0;
+}
+
+static int
+ohs900h_bus_resume(struct usb_hcd *hcd)
+{
+	// SOFs on
+	DBG("%s\n", __func__);
+	return 0;
+}
+
+#else
+
+#define	ohs900h_bus_suspend	NULL
+#define	ohs900h_bus_resume	NULL
+
+#endif
+
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef STUB_DEBUG_FILE
+
+static inline void create_debug_file(struct ohs900 *ohs900) { }
+static inline void remove_debug_file(struct ohs900 *ohs900) { }
+
+#else
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+static void dump_irq(struct seq_file *s, char *label, u8 mask)
+{
+	seq_printf(s, "%s %02x%s%s%s%s\n", label, mask,
+		(mask & OHS900_INTMASK_TRANS_DONE) ? " done" : "",
+		(mask & OHS900_INTMASK_SOFINTR) ? " sof" : "",
+		(mask & OHS900_INTMASK_INSRMV) ? " ins/rmv" : "",
+		(mask & OHS900_INTMASK_RESUME_DET) ? " rd" : "");
+}
+
+static int proc_ohs900h_show(struct seq_file *s, void *unused)
+{
+	struct ohs900		*ohs900 = s->private;
+	struct ohs900h_ep	*ep;
+	unsigned		i;
+	u8	t;
+	
+	seq_printf(s, "%s\n%s version %s\nportstatus[1] = %08x\n",
+		ohs900_to_hcd(ohs900)->product_desc,
+		hcd_name, DRIVER_VERSION,
+		ohs900->port1);
+
+	seq_printf(s, "insert/remove: %ld\n", ohs900->stat_insrmv);
+	seq_printf(s, "current session:  done_a %ld done_b %ld "
+			"wake %ld sof %ld overrun %ld lost %ld\n\n",
+		ohs900->stat_a, ohs900->stat_b,
+		ohs900->stat_wake, ohs900->stat_sof,
+		ohs900->stat_overrun, ohs900->stat_lost);
+
+	spin_lock_irq(&ohs900->lock);
+
+	t = ohs900_read(ohs900, OHS900_TXLINECTLREG);
+
+
+
+
+	seq_printf(s, "ctrl1 %02x%s%s%s%s\n", t,
+		(ohs900_read(ohs900, OHS900_SOFENREG)) ? " sofgen" : "",
+		({char *s; switch (t & OHS900_TXLCTL_MASK_LINE_CTRL_BITS) {
+		case OHS900_TXLCTL_MASK_NORMAL: s = ""; break;
+		case OHS900_TXLCTL_MASK_SE0: s = " se0/reset"; break;
+		case OHS900_TXLCTL_MASK_FS_K: s = " FS k/resume"; break;
+		case OHS900_TXLCTL_MASK_FS_J: s = " FS J/resume"; break;
+		default: s = " not valid ?"; break;
+		}; s; }),
+		(t & OHS900_TXLCTL_MASK_FS_POL) ? " fs pol" : " ls pol ",
+		(t & OHS900_TXLCTL_MASK_FS_RATE) ? " fs rate" : " ls rate ");
+
+	dump_irq(s, "irq_enable",
+			ohs900_read(ohs900, OHS900_IRQ_ENABLE));
+	dump_irq(s, "irq_status",
+			ohs900_read(ohs900, OHS900_IRQ_STATUS));
+	seq_printf(s, "frame clocks remaining:  %d\n",
+			ohs900_read(ohs900, OHS900_SOFTMRREG) << 6);
+
+
+	
+	seq_printf(s, "A: qh%p ctl %02x sts %02x\n", ohs900->active_a,
+		ohs900_read(ohs900, OHS900_HOST_TX_CTLREG),
+		ohs900_read(ohs900, OHS900_HRXSTATREG));
+	seq_printf(s, "\n");
+	list_for_each_entry (ep, &ohs900->async, schedule) {
+		struct urb		*urb;
+
+		seq_printf(s, "%s%sqh%p, ep%d%s, maxpacket %d"
+					" nak %d err %d\n",
+			(ep == ohs900->active_a) ? "(A) " : "",
+			(ep == ohs900->active_b) ? "(B) " : "",
+			ep, ep->epnum,
+			({ char *s; switch (ep->nextpid) {
+			case USB_PID_IN: s = "in"; break;
+			case USB_PID_OUT: s = "out"; break;
+			case USB_PID_SETUP: s = "setup"; break;
+			case USB_PID_ACK: s = "status"; break;
+			default: s = "?"; break;
+			}; s;}),
+			ep->maxpacket,
+			ep->nak_count, ep->error_count);
+		list_for_each_entry (urb, &ep->hep->urb_list, urb_list) {
+			seq_printf(s, "  urb%p, %d/%d\n", urb,
+				urb->actual_length,
+				urb->transfer_buffer_length);
+		}
+	}
+	if (!list_empty(&ohs900->async))
+		seq_printf(s, "\n");
+
+	seq_printf(s, "periodic size= %d\n", PERIODIC_SIZE);
+
+	for (i = 0; i < PERIODIC_SIZE; i++) {
+		ep = ohs900->periodic[i];
+		if (!ep)
+			continue;
+		seq_printf(s, "%2d [%3d]:\n", i, ohs900->load[i]);
+
+		/* DUMB: prints shared entries multiple times */
+		do {
+			seq_printf(s,
+				"   %s%sqh%d/%p (%sdev%d ep%d%s max %d) "
+					"err %d\n",
+				(ep == ohs900->active_a) ? "(A) " : "",
+				(ep == ohs900->active_b) ? "(B) " : "",
+				ep->period, ep,
+				(ep->udev->speed == USB_SPEED_FULL)
+					? "" : "ls ",
+				ep->udev->devnum, ep->epnum,
+				(ep->epnum == 0) ? ""
+					: ((ep->nextpid == USB_PID_IN)
+						? "in"
+						: "out"),
+				ep->maxpacket, ep->error_count);
+			ep = ep->next;
+		} while (ep);
+	}
+
+	spin_unlock_irq(&ohs900->lock);
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int proc_ohs900h_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ohs900h_show, PDE(inode)->data);
+}
+
+static const file_operations proc_ops = {
+	.open		= proc_ohs900h_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/* expect just one ohs900 per system */
+static const char proc_filename[] = "driver/ohs900";
+
+static void create_debug_file(struct ohs900 *ohs900)
+{
+	ohs900->pde = proc_create_data(proc_filename, 0, NULL, &proc_ops, ohs900)
+}
+
+static void remove_debug_file(struct ohs900 *ohs900)
+{
+	if (ohs900->pde)
+		remove_proc_entry(proc_filename, NULL);
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+static void
+ohs900h_stop(struct usb_hcd *hcd)
+{
+	struct ohs900	*ohs900 = hcd_to_ohs900(hcd);
+	unsigned long	flags;
+
+	del_timer_sync(&hcd->rh_timer);
+
+	spin_lock_irqsave(&ohs900->lock, flags);
+	port_power(ohs900, 0);
+	spin_unlock_irqrestore(&ohs900->lock, flags);
+}
+
+static int
+ohs900h_start(struct usb_hcd *hcd)
+{
+	struct ohs900		*ohs900 = hcd_to_ohs900(hcd);
+
+	/* chip has been reset, VBUS power is off */
+
+	hcd->state = HC_STATE_RUNNING;
+
+	if (ohs900->board) {
+		if (!device_can_wakeup(hcd->self.controller))
+			device_init_wakeup(hcd->self.controller,
+					   ohs900->board->can_wakeup);
+		hcd->power_budget = ohs900->board->power * 2;
+	}
+
+	/* enable power and interrupts */
+	port_power(ohs900, 1);
+
+	/* This is necessary to make the controller detect devices
+	 * that are already plugged in during initialisation. It
+	 * causes the hub driver to do a reset, which triggers
+	 * checking for an attached device. */
+	ohs900->port1 |= (1 << USB_PORT_FEAT_C_CONNECTION)
+		| (1 << USB_PORT_FEAT_CONNECTION);
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct hc_driver ohs900h_hc_driver = {
+	.description =		hcd_name,
+	.hcd_priv_size =	sizeof(struct ohs900),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			ohs900h_irq,
+	.flags =		HCD_USB11,
+
+	.start =		ohs900h_start,
+	.stop =			ohs900h_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		ohs900h_urb_enqueue,
+	.urb_dequeue =		ohs900h_urb_dequeue,
+	.endpoint_disable =	ohs900h_endpoint_disable,
+
+	/*
+	 * periodic schedule support
+	 */
+	.get_frame_number =	ohs900h_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data =	ohs900h_hub_status_data,
+	.hub_control =		ohs900h_hub_control,
+	.bus_suspend =		ohs900h_bus_suspend,
+	.bus_resume =		ohs900h_bus_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+#define resource_len(r) (((r)->end - (r)->start) + 1)
+
+static int __devexit
+ohs900h_remove(struct platform_device *dev)
+{
+	struct usb_hcd		*hcd = platform_get_drvdata(dev);
+	struct ohs900           *ohs900 = hcd_to_ohs900(hcd);
+	struct resource		*res;
+
+	remove_debug_file(ohs900);
+	usb_remove_hcd(hcd);
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (res)
+		iounmap(ohs900->addr_reg);
+
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+
+static int __devinit
+ohs900h_probe(struct platform_device *dev)
+{
+  
+  struct usb_hcd		*hcd;
+	struct ohs900		*ohs900;
+	struct resource		*addr, *data, *ires;
+	int			irq;
+	void __iomem		*addr_reg;
+	int			retval;
+	u8			tmp;
+	u8                      ioaddr = 0;
+	unsigned long		irqflags;
+
+	/* basic sanity checks first.  board-specific init logic should
+	 * have initialized these three resources and probably board
+	 * specific platform_data.  we don't probe for IRQs, and do only
+	 * minimal sanity checking.
+	 */
+
+
+	INFO("driver %s, starting ohs900h_probe\n", hcd_name);
+	ires = platform_get_resource(dev, IORESOURCE_IRQ, 0);
+	if (dev->num_resources < 3 || !ires)
+		return -ENODEV;
+
+	irq = ires->start;
+	irqflags = ires->flags & IRQF_TRIGGER_MASK;
+
+	/* refuse to confuse usbcore */
+	if (dev->dev.dma_mask) {
+		DBG("no we won't dma\n");
+		return -EINVAL;
+	}
+
+	addr = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	INFO("driver %s, ioremap addr->start = 0x%lX, resource_len(addr) = 0x%lx\n",
+		       	hcd_name, (unsigned long)(addr->start), (unsigned long)(resource_len(addr)) );
+			
+	retval = -EBUSY;
+	if (!addr) {
+		addr = platform_get_resource(dev, IORESOURCE_IO, 0);
+		if (!addr)
+			return -ENODEV;
+		ioaddr = 1;
+		INFO("driver %s, setting addr_reg to addr->start == 0x%X\n", hcd_name, addr->start) ;
+		addr_reg = (void __iomem *) (unsigned long) addr->start;
+	} else {
+		addr_reg = ioremap(addr->start, 1);
+		INFO("driver %s, setting addr_reg to ioremap(addr->start = 0x%lX) == 0x%lX\n", hcd_name, (unsigned long)(addr->start), (unsigned long)addr_reg) ;
+		if (addr_reg == NULL) {
+			retval = -ENOMEM;
+			goto err2;
+		}
+	}
+
+	/* allocate and initialize hcd */
+	INFO("driver %s, allocating memory\n", hcd_name);
+	hcd = usb_create_hcd(&ohs900h_hc_driver, &dev->dev, dev_name(&dev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err5;
+	}
+	hcd->rsrc_start = addr->start;
+	ohs900 = hcd_to_ohs900(hcd);
+
+	INFO("driver %s, spin_lock_init\n", hcd_name);
+	spin_lock_init(&ohs900->lock);
+	INIT_LIST_HEAD(&ohs900->async);
+	ohs900->board = dev->dev.platform_data;
+	init_timer(&ohs900->timer);
+	ohs900->timer.function = ohs900h_timer;
+	ohs900->timer.data = (unsigned long) ohs900;
+	ohs900->addr_reg = addr_reg;
+	spin_lock_irq(&ohs900->lock);
+
+	port_power(ohs900, 0);
+	INFO("driver %s, returned from port_power\n", hcd_name);
+	spin_unlock_irq(&ohs900->lock);
+	INFO("driver %s, returned from spin_unlock_irqrestore\n", hcd_name);
+	msleep(200);
+
+	INFO("driver %s, getting hw version\n", hcd_name);
+	tmp = ohs900_read(ohs900, OHS900_HWREVREG);
+	switch (tmp) {
+	case 0x7:
+		hcd->product_desc = "OHS900 v0.7";
+		break;
+	case 0x8:
+		hcd->product_desc = "OHS900 v0.8";
+		break;
+	case 0x10:
+		hcd->product_desc = "OHS900 v1.0";
+		break;
+	case 0x11:
+		hcd->product_desc = "OHS900 v1.1";
+		break;
+	case 0x12:
+		hcd->product_desc = "OHS900 v1.2";
+		break;
+	default:
+		/* reject other chip revisions */
+		DBG("chiprev %02x\n", tmp);
+		retval = -ENXIO;
+		goto err6;
+	}
+	INFO("driver %s, hw version = %d\n", hcd_name, tmp);
+
+	irqflags |= IRQF_SHARED;
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | irqflags);
+	if (retval != 0)
+		goto err6;
+
+	INFO("%s, irq %d\n", hcd->product_desc, irq);
+
+	create_debug_file(ohs900);
+	return retval;
+ err6:
+	usb_put_hcd(hcd);
+ err5:
+	if (!ioaddr)
+		iounmap(addr_reg);
+ err2:
+	DBG("init error, %d\n", retval);
+	return retval;
+}
+
+
+#ifdef	CONFIG_PM
+
+/* for this device there's no useful distinction between the controller
+ * and its root hub, except that the root hub only gets direct PM calls 
+ * when CONFIG_USB_SUSPEND is enabled.
+ */
+
+static int
+ohs900h_suspend(struct platform_device *dev)
+{
+	struct ohs900	*ohs900 = dev_get_drvdata(dev);
+	int		retval = 0;
+
+	if (phase != SUSPEND_POWER_DOWN)
+		return retval;
+
+	if (state <= PM_SUSPEND_MEM)
+		retval = ohs900h_bus_suspend(ohs900_to_hcd(ohs900));
+	else
+		port_power(ohs900, 0);
+	if (retval == 0)
+		dev->power.power_state = state;
+	return retval;
+}
+
+static int
+ohs900h_resume(struct platform_device *dev)
+{
+	struct ohs900	*ohs900 = dev_get_drvdata(dev);
+
+	if (phase != RESUME_POWER_ON)
+		return 0;
+
+	/* with no "check to see if VBUS is still powered" board hook,
+	 * let's assume it'd only be powered to enable remote wakeup.
+	 */
+	if (!ohs900->port1 || !ohs900_to_hcd(ohs900)->can_wakeup) {
+		ohs900->port1 = 0;
+		port_power(ohs900, 1);
+		return 0;
+	}
+
+	return ohs900h_bus_resume(ohs900_to_hcd(ohs900));
+}
+
+#else
+
+#define	ohs900h_suspend	NULL
+#define	ohs900h_resume	NULL
+
+#endif
+
+
+struct platform_driver ohs900h_driver = {
+	.probe =	ohs900h_probe,
+	.remove =	__devexit_p(ohs900h_remove),
+
+	.suspend =	ohs900h_suspend,
+	.resume =	ohs900h_resume,
+	.driver = {
+		.name =	(char *) hcd_name,
+		.owner = THIS_MODULE,
+	},
+};
+
+static struct resource ohs900_resources[] = { 
+ [0] = {
+   .start          = (OHS900_BASE),
+   .end            = ((OHS900_BASE) + OHS900_IO_EXTENT - 1),
+   .flags          = IORESOURCE_MEM,
+ },
+ [1] = {
+   .start          = (OHS900SLAVE_BASE),
+   .end            = ((OHS900SLAVE_BASE) + OHS900_IO_EXTENT - 1),
+   .flags          = IORESOURCE_MEM,
+ },
+ [2] = {
+   .start          = (OHS900_IRQ),
+   .end            = (OHS900_IRQ),
+   .flags          = IORESOURCE_IRQ,
+ },
+ [3] = {
+   .start          = (OHS900SLAVE_IRQ),
+   .end            = (OHS900SLAVE_IRQ),
+   .flags          = IORESOURCE_IRQ,
+ },
+};
+
+
+static void sm3k_port_power(struct device *dev, int is_on) {
+	INFO("driver %s, inside stubbed sm3k_port_power\n", hcd_name);
+ // see linux/usb_ohs900.h
+}
+static void sm3k_hc_reset(struct device *dev) {
+ // see linux/usb_ohs900.h
+	struct ohs900	*ohs900 = dev_get_drvdata(dev);
+
+	INFO("Resetting core\n");
+	ohs900_write(ohs900, OHS900_HOSTSLAVECTLREG, OHS900_HSCTLREG_RESET_CORE);
+}
+struct ohs900_platform_data sm3k_ohs900 = {
+ .potpg = 10,
+ .power = 250,
+ .port_power = sm3k_port_power,
+ .reset = sm3k_hc_reset,
+};
+static struct platform_device ohs900_device = {
+ .name           = "ohs900-hcd",
+ .id             = -1,
+ .dev = {
+   .platform_data = &sm3k_ohs900,
+   .release = ohs900_release,
+ },
+ .num_resources  = ARRAY_SIZE(ohs900_resources),
+ .resource       = ohs900_resources,
+};
+
+
+/*-------------------------------------------------------------------------*/
+
+void ohs900_release(struct device *dev) {
+	/*
+	  This function is needed because otherwise the
+	  platform_device_unregister() call fails. Should we be actually
+	  doing something here?
+	 */
+}
+ 
+static int __init ohs900h_init(void) 
+{
+	if (usb_disabled())
+		return -ENODEV;
+	
+	platform_device_register(&ohs900_device); 
+	
+	INFO("driver %s, %s\n", hcd_name, DRIVER_VERSION);
+	return platform_driver_register(&ohs900h_driver);
+}
+module_init(ohs900h_init);
+
+static void __exit ohs900h_cleanup(void) 
+{	
+	platform_driver_unregister(&ohs900h_driver);
+	platform_device_unregister(&ohs900_device);
+}
+module_exit(ohs900h_cleanup);
